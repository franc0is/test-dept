README for the Test Dept. Framework
===================================
This README consists of a couple of sections, namely:

·Introduction
·The Suite Concept
·Test Dependencies
·A C-Implementation
·Using Replacement Functions or Stubs
·Directory Structure
·Contact Information

Introduction
------------
The goals of the Test Dept. framework for unit-testing are to:

·Be usable for pure C-projects
·Support stubs for C (or at least replaceable functions)
·Be compatible with different test runners
·Encourage independent test cases

In practice, these goals are (somewhat) reached by:

·A macro-based assertion suite for C
·Makefile snippets for replacing symbols in SUT for stubbing
·Standardizing the observable test suite behavior
·Using runnable binaries as suites - one binary per suite

These concepts are all described later in this README. For everything
to work properly there are some prerequisites:

·It needs GNU make(1) for building suites.
·It uses objcopy(1) and nm(1) for stubbing.
·It depends on the __LINE__ and __FILE__ macros of gcc(1) for assertions.
·It uses awk(1) and sed(1) for some textfile processing.

Both nm(1) and objcopy(1) are often parts of a "binutils" package.


The Suite Concept
-----------------
A test suite contains one or more test cases.  A test runner can run
several test suites in succession.

-----1-----------2----/ ... /----n---> time
+---------+ +---------+     +---------+
| suite 1 | | suite 2 |	... | suite n |
+---------+ +---------+	    +---------+

As stated above one or more test cases comprise such a test suite:

-----1-----------2----/ ... /----n---> time
+---------+ +---------+     +---------+
| suite 1 | | suite 2 |	    | suite n |
|         | |         |     |         |
|  case 1 | |  case 1 |     |  case 1 |
|  case 2 | |  case 2 | ... |  case 2 |
|    :    | |    :    |     |    :    |
|  case n | |  case n |     |  case n |
+---------+ +---------+	    +---------+

In its basic form the contained cases are run one at a time.  Each
test case execution is spawned by running a suite binary while
specifying a case to run.  For example:

 > ./my_test name_of_test_case_to_run

That is: each suite is a binary of its own!  This is a different
philosophy from many other test frameworks, where all suites and
sub-suites often are packed into the same binary.

Moreover, for an external test runner to be able to enumerate the
different test cases from a suite, the binary has to be able to state
which cases it contains.  This is done by specifying zero arguments to
the binary.  The default printout should be a list of cases:

 > ./my_test
 test_foo
 test_bar
 test_fie

A final property of a test suite is that it has to return some
information to the runner regarding the actual test execution.  If the
suite returns zero, then everything went OK.  If it returns 1, then one
test failure occured.  If it returns 2, then two failures occured...
Since a runner normally will run only one case at a time from a
binary, the normal result is 1 or 0.

A potential runner execution could look like this:

 > test_dept.sh my_first_test my_other_test some_more_tests

and the printout is test runner specific, even how it handles standard
output and standard error output.

As a final twist, a suite binary is expected to accept more than one
test case at the same time, in any order.  For example:

 >  ./my_test test_bar test_foo

which will run both the test_bar and test_foo cases and return the
accumulated number of failures as exit status.  This opens for a
possible (but not recommended) way of implementing test runners that
could render dependent test cases!

In conclusion.  A suite that conforms to the rules of the Test
Dept. framework shall:

·return the names of all its test casesif zero arguments given
·run all test cases whose names are supplied on the command line
·return the cumulative failure count of all run cases as exit status
·return -1 on strange arguments


Test Dependencies
-----------------
Testing something, hereby called System Under Test (SUT), almost
always implies haveing dependencies to other parts of a system.  For
example, when testing a C-object-file, it almost always refers to
symbols from other object files.  Consider for example testing of
SUT.o which has dependencies to foo.o and bar.o:

 test-program
      |
      v
    sut.o ----- bar.o
      |
      |
    foo.o

A test program which tests the SUT is hardly interesting in
side-effects from bar.o or foo.o.  At least it is worth striving for
not to be dependent of them when performing unit-tests.

What is often desirable is to shor circuit different parts of the
dependency chain when testing parts of the SUT that accesses its
surroundings.  This is sometimes necessary.  For example, when testing
functionality in SUT that depends on foo, parts of the dependencies
can be directed back to the test program:

 test-program
      |     ^
      v     |
    sut.o --´   bar.o
      |
      |
    foo.o

Doing this, a tester can simulate for example an unsuccessful malloc
or a broken file-open-function somewhere.  Sometimes this is called
using a stub, a test-dummy, a mock-object or something even more
creative.  What it really is depends on the scenario.  In this text it
is henceforth called "stubbing".  Please refer to later paragraphs in
this file for a more comprehensive guide on how this could be achieved
for C-code.


A C-implementation
------------------
A C-implementation is provided in the framework.  And as far as that
C-implementation is concerned, a suite contains one or more cases and
zero or more of setup/teardown procedures.  The setup/teardown concept
is by no means a new invention.  It is used by many other types of
test frameworks.  Stacking many cases in the same suite makes good use
of a shared setup procedure, for example.

+--------------------+
| suite              |
|                    |
|  +--------------+  |
|  |    setup     |  |
|  +--------------+  |
|  .------.          |
|  |case 1|-.        |
|  `------´2|        |
|    `------´        |
|           ..       |
|          .------.  |
|          |case n|  |
|          `------´  |
|  +--------------+  |
|  |   teardown   |  |
|  +--------------+  |
+--------------------+

When a suite is run its cases are executed in rapid succession
together with setup code (if any) run in prior and teardown code (if
any) run after each case.

 ---------- 1 -------------------- 2 ---------/ ... /---------- n -------> time

+---------------------+ +---------------------+     +---------------------+
| |                   | | |                   |     | |                   |
| | +--------------+  | | | +--------------+  |     | | +--------------+  |
| 1 |    setup     |  | | 1 |    setup     |  |     | 1 |    setup     |  |
| | +--------------+  | | | +--------------+  |     | | +--------------+  |
| |     .------.      | | |     .------.      |     | |     .------.      |
| 2     |case 1|      | | 2     |case 2|      | ... | 2     |case n|      |
| |     `------´      | | |     `------´      |     | |     `------´      |
| | +--------------+  | | | +--------------+  |     | | +--------------+  |
| 3 |   teardown   |  | | 3 |   teardown   |  |     | 3 |   teardown   |  |
| | +--------------+  | | | +--------------+  |     | | +--------------+  |
| V                   | | V                   |     | V                   |
+---------------------+ +---------------------+     +---------------------+

With the C implementation a simple way to construct a test case is to
include test_dept.h and make test-functions:

 /* foo_test.c */
 #include <test_dept.h>
 
 extern int value;
 
 static void test_add_one() {
   int foo = value + 1;
   assert_equals(4, foo);
 }

 static void test_init_value() {
   assert_equals(3, value);
 }
 
 static void setup() {
   value = 3;
 }

In order to run the tests, simply use something like this in your
makefile (after installing Test Dept. in your environment, of course):

 CC=gcc
 LD=$(CC)
 
 TEST_SRCS=foo_test.c
 
 include test_dept_simple.mk

which will produce a binary called "foo_test".  Then issue:

 > make test_dept_run

which will run the default test runner that comes with Test Dept.  It
will call all test suite binaries.  In this case only "foo_test".
Please note that the test suite binary will be run once per test case
in the suite.  Not once per suite.  There is a subtle difference being
that the former form of running tests forec them to be completely
independent of each other.

Using Replacement Functions or Stubs
------------------------------------
Stubbing is often desirable when isolated tests on a SUT are required.
This is often the case when unit-testing.  The Test Dept. framework
offers a simple stubbing mechanism relying on symbol replacements in
object files.

For example: construct a test case for a SUT called sut, with stubs,
like this:

 /* test_sut.c */
 #include <test_dept.h>
 #include <stdlib.h>
 #include "function_switch.h" 
 #include "foo.o"
 
 static int failing_do_foo_function(int number_of_fish) {
   return 0; //failure code for foo_function;
 }
 
 static void *failing_malloc(size_t size) {
   return NULL; //always fail
 }
 
 static void test_normal_fie() {
   int result = fie(8); /* calls do_foo() from foo.h */
   assert_equals(3, result);
 }
 
 static void test_fie_with_failing_foo_operation() {
   test_dept_do_foo_set(&failing_do_foo_function);
   int result = fie(8);
   assert_equals(0, result);
 }
 
 static void test_fie_with_failing_malloc() {
   test_dept_malloc_set(&failing_malloc);
   int result = fie(8);
   assert_equals(-1, result);
 }

Also construct a file called "stubs.h" for example where all possible
stub function prototypes are put.  In this particular case "do_foo" is
normally provided by foo.o and malloc is a part of a standard libc.
They are both added to the same stubs-file for convenience when
testing:

 /* stubs.h */
 void *malloc(size_t size);
 int do_foo(int number_of_fish);

Then two lines in the makefile for the stubs file:

 TEST_DEPT_POSSIBLE_STUBS=stubs.h
 TEST_DEPT_FUNCTION_SWITCH_HEADER=function_switch.h

and the test-case should compile if sut_test.c is added to the
makefile as described earlier in the simple example. The latter of the
two lines above indicate a file that will be _generated_.  I. e. you
do not have to create such a file.  That file is included in the
testcase code above.

This is a complete makefile example which will work if you have
installed Test Dept. in your environment:

 CC=gcc
 LD=$(CC)

 TEST_DEPT_POSSIBLE_STUBS=stubs.h
 TEST_DEPT_FUNCTION_SWITCH_HEADER=function_switch.h

 TEST_SRCS=sut_test.c

 sut_test: foo.o
 
 include test_dept_simple.mk

Please note that this simple way of expressing the makefiles expect a
file called sut.c to exist.  If not, the test will not compile.  If
you need to deviate from that simple rule you will have to specify
some dependencies by yourself.  In short, the simple makefile above is
roughly equivalent to this one:

 CC=gcc
 LD=$(CC)

 TEST_DEPT_POSSIBLE_STUBS=stubs.h
 TEST_DEPT_FUNCTION_SWITCH_HEADER=function_switch.h

 TEST_SRCS=sut_test.c

 sut_test: sut_using_stubs.o sut_stubs.o foo.o

 include test_dept_normal.mk

And that concludes a quick walkthrough of the Test Dept. framework.


Directory Structure
-------------------
The software is structured like this when packaged as a source
tar-file:

 test_dept
  |
  +- COPYING          Licensing information for Test Dept.
  +- INSTALL          Installation information
  +- Makefile.in      Template Makefile
  +- README           This file
  +- configure        Configuration script that creates a Makefile
  +- examples         Example projects that use Test Dept.
  +- install-sh       Fallback installation program
  +- simple_project   A simpler example project that uses Test Dept.
  `- src              Scripts and makefile snippets that comprise the framework


Contact Information
-------------------
M Norrby <norrby+test-dept@lysator.liu.se>.
