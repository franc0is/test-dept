#summary Automating tests renders an effective way of working

=Automation=
In general, test automation is good. However, when test work is automated
it tends to cause a less flexible environment.  As a programmer you are
more tied to the framework used.  The reality looks somewhat like
the graph below:

http://chart.apis.google.com/chart?chxt=x,y,x,y&chxl=0:|strict|full%20control|1:|manual|automatic|2:|Flexibility|3:|Automation&chxp=0,20,100|1,20,100|2,50|3,60&chxs=3,339933,14|2,3333dd,14&cht=lc&chs=400x225&chd=t:-1,100,50,30,27,25,23,22,21,20,20&nonsense=something_that_ends_with.png

This is not necessarily a good thing.  When programmers are forces
in line simply by not being able to stray out of them, projects
tend to focus.  At least that is the [TestDept Test Dept.] philosophy.

==Different ways of automating tests with Test Dept.==
[TestDept Test Dept.] is usable in a couple of ways:

  * Without fuzz; i e the usage described on the [TestDept frontpage]
  * With some manual intervention, but still automated
  * Manual use of all, or some, of [TestDept Test Dept.]'s convenience functionality

These different ways of usage are described below.

=How it works=
When testing C code the systems under test are often object-files
or `o-files` for short. As described in the [TestDept introduction]
systems under test are rarely standalone.  The `o-files` depend
on symbols from other `o-files`.  A unit test program can access
its compilation unit under test but it has no control over how
it really interacts with its dependencies:

http://test-dept.googlecode.com/svn/trunk/doc/art/test_dependencies.png

The system under test might contain a reference to a foreign function
`foo()`:

http://test-dept.googlecode.com/svn/trunk/doc/art/functions.png

If the symbol were to be replaced with something else in the sut,
the reality would look somewhat like the figure below instead:

http://test-dept.googlecode.com/svn/trunk/doc/art/stub_functions.png

The switching functionality illustrated above could be made controllable
from a unit test case.  That way it is possible to make runtime
switching, which allows for powerful unit testing.  If the function
symbol was forced to reference a switch function instead, the scenario
would look like this:

http://test-dept.googlecode.com/svn/trunk/doc/art/stub_switch.png

The [TestDept Test Dept.] framework allows for such switching. It
automatically creates switches for all foreign symbols that are used
from the sut `o-file`. In practice this is accomplished by calling
`replace_function(...)` in the framework:
{{{
 void *my_own_malloc(size_t size) { /* ... */ }
 void test_something() {
   replace_function(&malloc, &my_own_malloc);
   call_something_that_uses_malloc();
   restore_function(&malloc);
 }
}}}