#summary Automating tests renders an effective way of working

=Automation=
In general, test automation is good. However, when test work is automated
it tends to cause a less flexible environment.  As a programmer you are
more tied to the framework used.  The reality looks somewhat like
the graph below:

http://chart.apis.google.com/chart?chxt=x,y,x,y&chxl=0:|strict|full%20control|1:|manual|automatic|2:|Flexibility|3:|Automation&chxp=0,20,100|1,20,100|2,50|3,60&chxs=3,339933,14|2,3333dd,14&cht=lc&chs=400x225&chd=t:-1,100,50,30,27,25,23,22,21,20,20&nonsense=something_that_ends_with.png

This is not necessarily a good thing.  When programmers are forces
in line simply by not being able to stray out of them, projects
tend to focus.  At least that is the [TestDept Test Dept.] philosophy.

==Different ways of automating tests with Test Dept.==
[TestDept Test Dept.] is usable in a couple of ways:

  * Without fuzz; i e the usage described on the [TestDept frontpage]
  * With some manual intervention, but still automated
  * Manual use of all, or some, of [TestDept Test Dept.]'s convenience functionality

These different ways of usage are described below.

=How it works=
When testing C code the systems under test are often object-files
or `o-files` for short. As described in the [TestDept introduction]
systems under test are rarely standalone.  The `o-files` depend
on symbols from other `o-files`.  A unit test program can access
its compilation unit under test but it has no control over how
it really interacts with its dependencies:

http://test-dept.googlecode.com/svn/trunk/doc/art/test_dependencies.png

The system under test might contain a reference to a foreign function
`foo()`:

http://test-dept.googlecode.com/svn/trunk/doc/art/functions.png

If the symbol were to be replaced with something else in the sut,
the reality would look somewhat like the figure below instead:

http://test-dept.googlecode.com/svn/trunk/doc/art/stub_functions.png

The switching functionality illustrated above could be made controllable
from a unit test case.  That way it is possible to make runtime
switching, which allows for powerful unit testing.  If the function
symbol was forced to reference a switch function instead, the scenario
would look like this:

http://test-dept.googlecode.com/svn/trunk/doc/art/stub_switch.png

The [TestDept Test Dept.] framework allows for such switching. It
automatically creates switches for all foreign symbols that are used
from the sut `o-file`. In practice this is accomplished by calling
`replace_function()` in the framework:
{{{
 void *my_own_malloc(size_t size) { /* ... */ }

 void test_something() {
   replace_function(&malloc, &my_own_malloc);
   call_something_that_uses_malloc();
   restore_function(&malloc);
 }
}}}
The key is the `replace_function()` function.

==Assembly language==
Using solely C-code for creating a `replace_function(...)` function like
the one described above together with function switch proxies is impossible.
There is no way for a proxy to know which arguments to pass to a
wrapped function without having access to its prototype.

However, if we allow for an assembly language switching function, the proxy
function could just make a `jmp` to the chosen function, without disrupting
the stack or registers. Doing so surpasses the need for an explicit prototype
for the wrapped function.

This is how [TestDept Test Dept.] works. It replaces the foreign symbols
in the `sut.o` creating a `sut_using_proxies.o` file. The latter object
file contains references to switching functions that are implemented in
assembly language. Each switching function has access to a function pointer
pointing either to the original function or a stub function.

Those pointers are accessible from the test-program. And the
`replace_function()` mentioned earlier just manipulates them to
redirect calls.